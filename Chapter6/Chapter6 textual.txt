6.1 实参是形参的初始值，形参是形式上的参数，在函数定义时声明

6.2 a) 返回值类型错误
    b) 没有声明返回值类型
    c) 重复声明
    d) 没有花括号

6.12 引用，因为引用可以直接修改，虽然本质上也是指针

6.13 void f(T)是把T类型的变量作为形参的定义，不能改变实参的值，而void f(&T)可以。

6.14 将一个数字置成42，打开一个文件

6.15 因为s不能被函数修改，因为c是临时变量,occurs会是0

6.16 因为不改变s的值，所以改成const

6.18 a) bool compare(matrix &m1, matrix &m2);
     b) vector<int>::iterator change_val(int, vector<int>::iterator);

6.19 a) 不合法
     b) 合法
     c) 合法
     d) 合法

6.20 不修改实参，改变实参

6.24 传递数组方式出错，应该改成(*ia)[10]

6.28 string&

6.29 因为list不能改变值，所以不行

6.31 局部临时变量或者局部对象的引用对于返回都是无效的

6.32 合法，赋给ia 0-9

6.34 当参数为负数时，死循环

6.35 后置递增是执行语句后再加，死循环

6.36 int (*function(int val))[10];

6.37 auto function(int i) -> int(*)[10];
     decltype(odd) *arrPtr(int i);
     ArrT = string[10];

6.38 decltype(arrPtr)& arrPtr(int i){
          return (i%2) ? odd : even;
     }

6.39 a) 错误，都是int
     b) 错误，只有返回值不一样是不行的
     c) 正确

6.40 b) 错误的，一旦函数的某个形参被赋予了默认值，他后面所有的参数都必须有默认值

6.41 a) 不合法，没有提供第一个参数
     b) 合法
     c) 合法，但是给wd赋值‘*’

6.43 a) 因为他是内联函数

6.44 内联函数只需要加inline就行

6.46 constexpr函数是指能用于常量表达式的函数，如果函数有且只有一条返回语句，并且返回类型及所有形参类型都得是字面值类型

6.48 不合理，因为cin只要有输入就是true

6.49 函数匹配的第一步是选定本次调用的重载函数集，集合中的函数被称为候选函数；
     从候选函数中挑选出能被实参调用的函数，此次选出的函数被称为可行函数。

6.50 a) 不合法，第一个为int//合法第三个
     b) 合法，第三个
     c) 合法，第三个
     d) 合法，第4个

6.52 a) 类型提升
     b) 算术类型转换

6.53 都是对第一条语句

6.54 int (*f(int))(int, int);